import asyncio
import os
import sys

from nillion_client import (
   InputPartyBinding,
   Network,
   NilChainPayer,
   NilChainPrivateKey,
   OutputPartyBinding,
   Permissions,
   SecretInteger,
   VmClient,
   PrivateKey,
)
from dotenv import load_dotenv

home = os.getenv("HOME")
env_path = f"{home}/.config/nillion/nillion-devnet.env"

# Check if env file exists
if not os.path.exists(env_path):
    print(f"Error: Environment file not found at {env_path}")
    print("Please make sure the nillion-devnet is properly set up.")
    print("You may need to run: nillion-devnet create")
    sys.exit(1)

load_dotenv(env_path)

async def main():
    # 2. Initial setup, Initialize NillionClient against nillion-devnet
    try:
        # Use the devnet configuration generated by `nillion-devnet`
        network = Network.from_config("devnet")
    except KeyError as e:
        print(f"Error: Missing configuration key '{e}'")
        print("The devnet configuration format may have changed.")
        print("Please ensure you have the latest version of nillion-client and nillion-devnet tools.")
        print("Try updating with: pip install -U nillion-client")
        print("And recreate your devnet: nillion-devnet create")
        sys.exit(1)
    # Create payments config and set up Nillion wallet with a private key to pay for operations
    nilchain_key: str = os.getenv("NILLION_NILCHAIN_PRIVATE_KEY_0")  # type: ignore
    payer = NilChainPayer(
        network,
        wallet_private_key=NilChainPrivateKey(bytes.fromhex(nilchain_key)),
        gas_limit=10000000,
    )

    # Use a random key to identify ourselves
    signing_key = PrivateKey()
    client = await VmClient.create(signing_key, network, payer)
    party_name = "Party1"
    program_name = "secret_addition_complete"
    program_mir_path = f"../nada_quickstart_programs/target/{program_name}.nada.bin"

    # Adding funds to the client balance so the upcoming operations can be paid for
    funds_amount = 3000000
    print(f"üí∞  Adding some funds to the client balance: {funds_amount} uNIL")
    await client.add_funds(funds_amount)
    # 3. Store the program
    print("-----STORE PROGRAM")

    # Store program
    program_mir = open(program_mir_path, "rb").read()
    program_id = await client.store_program(program_name, program_mir).invoke()

    # Print details about stored program
    print(f"Stored program_id: {program_id}")
    # 4. Create the 1st secret, add permissions and store it in the network
    print("-----STORE SECRETS")

    # Create a secret
    values = {
        "my_int1": SecretInteger(500),
    }

    # Create a permissions object to attach to the stored secret
    permissions = Permissions.defaults_for_user(client.user_id).allow_compute(
        client.user_id, program_id
    )

    # Store a secret
    values_id = await client.store_values(
        values, ttl_days=5, permissions=permissions
    ).invoke()

    # 5. Create compute bindings to set input and output parties, add a computation time secret & run the computation
    print("-----COMPUTE")

    # Bind the parties in the computation to the client to set input and output parties
    input_bindings = [InputPartyBinding(party_name, client.user_id)]
    output_bindings = [OutputPartyBinding(party_name, [client.user_id])]

    # Create a computation time secret to use
    compute_time_values = {"my_int2": SecretInteger(10)}

    # Compute, passing in the compute time values as well as the previously uploaded value.
    print(f"Invoking computation using program {program_id} and values id {values_id}")
    compute_id = await client.compute(
        program_id,
        input_bindings,
        output_bindings,
        values=compute_time_values,
        value_ids=[values_id],
    ).invoke()

    # 6. Return the computation result
    print(f"The computation was sent to the network. compute_id: {compute_id}")
    result = await client.retrieve_compute_results(compute_id).invoke()
    print(f"‚úÖ  Compute complete for compute_id {compute_id}")
    print(f"üñ•Ô∏è  The result is {result}")
    balance = await client.balance()
    print(f"üí∞  Final client balance: {balance.balance} Credits")
    client.close()
    return result

if __name__ == "__main__":
    asyncio.run(main())